import{g as V}from"./index.js";import{V as D}from"./index12.js";import"./index15.js";function I(n){if(n)throw n}var b,T;function F(){if(T)return b;T=1;var n=Object.prototype.hasOwnProperty,t=Object.prototype.toString,i=Object.defineProperty,r=Object.getOwnPropertyDescriptor,o=function(e){return typeof Array.isArray=="function"?Array.isArray(e):t.call(e)==="[object Array]"},l=function(e){if(!e||t.call(e)!=="[object Object]")return!1;var s=n.call(e,"constructor"),c=e.constructor&&e.constructor.prototype&&n.call(e.constructor.prototype,"isPrototypeOf");if(e.constructor&&!s&&!c)return!1;var u;for(u in e);return typeof u>"u"||n.call(e,u)},f=function(e,s){i&&s.name==="__proto__"?i(e,s.name,{enumerable:!0,configurable:!0,value:s.newValue,writable:!0}):e[s.name]=s.newValue},p=function(e,s){if(s==="__proto__")if(n.call(e,s)){if(r)return r(e,s).value}else return;return e[s]};return b=function a(){var e,s,c,u,y,d,h=arguments[0],m=1,j=arguments.length,g=!1;for(typeof h=="boolean"&&(g=h,h=arguments[1]||{},m=2),(h==null||typeof h!="object"&&typeof h!="function")&&(h={});m<j;++m)if(e=arguments[m],e!=null)for(s in e)c=p(h,s),u=p(e,s),h!==u&&(g&&u&&(l(u)||(y=o(u)))?(y?(y=!1,d=c&&o(c)?c:[]):d=c&&l(c)?c:{},f(h,{name:s,newValue:a(g,d,u)})):typeof u<"u"&&f(h,{name:s,newValue:u}));return h},b}var _=F();const x=V(_);function z(n){if(typeof n!="object"||n===null)return!1;const t=Object.getPrototypeOf(n);return(t===null||t===Object.prototype||Object.getPrototypeOf(t)===null)&&!(Symbol.toStringTag in n)&&!(Symbol.iterator in n)}function k(){const n=[],t={run:i,use:r};return t;function i(...o){let l=-1;const f=o.pop();if(typeof f!="function")throw new TypeError("Expected function as last argument, not "+f);p(null,...o);function p(a,...e){const s=n[++l];let c=-1;if(a){f(a);return}for(;++c<o.length;)(e[c]===null||e[c]===void 0)&&(e[c]=o[c]);o=e,s?L(s,p)(...e):f(null,...e)}}function r(o){if(typeof o!="function")throw new TypeError("Expected `middelware` to be a function, not "+o);return n.push(o),t}}function L(n,t){let i;return r;function r(...f){const p=n.length>f.length;let a;p&&f.push(o);try{a=n.apply(this,f)}catch(e){const s=e;if(p&&i)throw s;return o(s)}p||(a&&a.then&&typeof a.then=="function"?a.then(l,o):a instanceof Error?o(a):l(a))}function o(f,...p){i||(i=!0,t(f,...p))}function l(f){o(null,f)}}const N=function(n){const r=this.constructor.prototype,o=r[n],l=function(){return o.apply(l,arguments)};return Object.setPrototypeOf(l,r),l},U={}.hasOwnProperty;class A extends N{constructor(){super("copy"),this.Compiler=void 0,this.Parser=void 0,this.attachers=[],this.compiler=void 0,this.freezeIndex=-1,this.frozen=void 0,this.namespace={},this.parser=void 0,this.transformers=k()}copy(){const t=new A;let i=-1;for(;++i<this.attachers.length;){const r=this.attachers[i];t.use(...r)}return t.data(x(!0,{},this.namespace)),t}data(t,i){return typeof t=="string"?arguments.length===2?(O("data",this.frozen),this.namespace[t]=i,this):U.call(this.namespace,t)&&this.namespace[t]||void 0:t?(O("data",this.frozen),this.namespace=t,this):this.namespace}freeze(){if(this.frozen)return this;const t=this;for(;++this.freezeIndex<this.attachers.length;){const[i,...r]=this.attachers[this.freezeIndex];if(r[0]===!1)continue;r[0]===!0&&(r[0]=void 0);const o=i.call(t,...r);typeof o=="function"&&this.transformers.use(o)}return this.frozen=!0,this.freezeIndex=Number.POSITIVE_INFINITY,this}parse(t){this.freeze();const i=w(t),r=this.parser||this.Parser;return P("parse",r),r(String(i),i)}process(t,i){const r=this;return this.freeze(),P("process",this.parser||this.Parser),E("process",this.compiler||this.Compiler),i?o(void 0,i):new Promise(o);function o(l,f){const p=w(t),a=r.parse(p);r.run(a,p,function(s,c,u){if(s||!c||!u)return e(s);const y=c,d=r.stringify(y,u);B(d)?u.value=d:u.result=d,e(s,u)});function e(s,c){s||!c?f(s):l?l(c):i(void 0,c)}}}processSync(t){let i=!1,r;return this.freeze(),P("processSync",this.parser||this.Parser),E("processSync",this.compiler||this.Compiler),this.process(t,o),S("processSync","process",i),r;function o(l,f){i=!0,I(l),r=f}}run(t,i,r){C(t),this.freeze();const o=this.transformers;return!r&&typeof i=="function"&&(r=i,i=void 0),r?l(void 0,r):new Promise(l);function l(f,p){const a=w(i);o.run(t,a,e);function e(s,c,u){const y=c||t;s?p(s):f?f(y):r(void 0,y,u)}}}runSync(t,i){let r=!1,o;return this.run(t,i,l),S("runSync","run",r),o;function l(f,p){I(f),o=p,r=!0}}stringify(t,i){this.freeze();const r=w(i),o=this.compiler||this.Compiler;return E("stringify",o),C(t),o(t,r)}use(t,...i){const r=this.attachers,o=this.namespace;if(O("use",this.frozen),t!=null)if(typeof t=="function")a(t,i);else if(typeof t=="object")Array.isArray(t)?p(t):f(t);else throw new TypeError("Expected usable value, not `"+t+"`");return this;function l(e){if(typeof e=="function")a(e,[]);else if(typeof e=="object")if(Array.isArray(e)){const[s,...c]=e;a(s,c)}else f(e);else throw new TypeError("Expected usable value, not `"+e+"`")}function f(e){if(!("plugins"in e)&&!("settings"in e))throw new Error("Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither");p(e.plugins),e.settings&&(o.settings=x(!0,o.settings,e.settings))}function p(e){let s=-1;if(e!=null)if(Array.isArray(e))for(;++s<e.length;){const c=e[s];l(c)}else throw new TypeError("Expected a list of plugins, not `"+e+"`")}function a(e,s){let c=-1,u=-1;for(;++c<r.length;)if(r[c][0]===e){u=c;break}if(u===-1)r.push([e,...s]);else if(s.length>0){let[y,...d]=s;const h=r[u][1];z(h)&&z(y)&&(y=x(!0,h,y)),r[u]=[e,y,...d]}}}}const H=new A().freeze();function P(n,t){if(typeof t!="function")throw new TypeError("Cannot `"+n+"` without `parser`")}function E(n,t){if(typeof t!="function")throw new TypeError("Cannot `"+n+"` without `compiler`")}function O(n,t){if(t)throw new Error("Cannot call `"+n+"` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.")}function C(n){if(!z(n)||typeof n.type!="string")throw new TypeError("Expected node, got `"+n+"`")}function S(n,t,i){if(!i)throw new Error("`"+n+"` finished async. Use `"+t+"` instead")}function w(n){return q(n)?n:new D(n)}function q(n){return!!(n&&typeof n=="object"&&"message"in n&&"messages"in n)}function B(n){return typeof n=="string"||R(n)}function R(n){return!!(n&&typeof n=="object"&&"byteLength"in n&&"byteOffset"in n)}export{H as unified};
